2 컴퓨터 시스템
==
현대의 컴퓨터 시스템은 버스로 연결되어 있다. 이러한 각각의 요소들을 운영체제가 다루고 제어한다. 입출력 장치와 CPU는 동시에 동작하며 각 장치 제어기(Device Controller)는 제어를 담한다. 장치만을 위한 버퍼 메모리를 가지고 있음, 이는 장치 드라이버에 의해 관리된다. CPU는 메인메모리의 값과 컨트롤러의 local메모리의 값을 서로 주고 받을 수 있음 장치 제이거는 CPU와 데이터 전송을 인터럽트로 주고 받는다.

###### 인터럽트
마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에 처리를 요청하는 것이다. CPU가 인터럽트를 감지하면 지금 실행중인 기계어 코드를 중단하고 해당 인터럽트를 위한 처리 프로그램으로 점프하여 일을 수행한다.

<p align="center"><img src = "https://user-images.githubusercontent.com/40592785/107343462-ad82be00-6b04-11eb-880c-da73770adb91.jpg" width="400" height="300"></p>


#### 폰 노이만 구조
폰 노이만 구조는 CPU, 메모리, 프로그램 세 가지 요소로 CPU와 메모리는 분리되어 버스를 통해 명령어 읽기, 데이터의 읽고 쓰기를 통해 처리하는 방식이다. 컴퓨터에 작업을 시킬 때 하드웨어를 재배치하지 않고 소프트웨어만 교체하여 사용하는 것이다. 현재 모든 컴퓨터들은 폰 노이만 구조를 따른다.

<p align="center"><img src = "https://user-images.githubusercontent.com/40592785/107328304-dc436900-6af1-11eb-8bef-56542e1a70d2.png"></p>

###### 버스
CPU가 처리한 데이터들은 모니터에 출력되거나 메모리에 저장되어 진다. 이러한 행위가 이루어지기 위해서는 데이터들이 각 컴포넌트끼리 통신이 가능해야한다. 이러한 통신을 가능하게 해주는 것이 버스이다.

System Bus : 전송하는 정보의 타입은 3가지로 
- Address Bus : 데이터 전송을 할 때 데이터가 메모리의 어디에 있는지 위치 정보
- Data Bus : 연산된 결과와 같이 의미있는 값 정보
- Control Bus : 앞의 주소 정보와 실제 데이터가 어떤 방향으로 전송되어야하는지에 대한 데이터 흐름

I/O Bus : CPU와 메모리를 연결하는 시스템 버스

## 부팅

컴퓨터가 구동을 시작하기 위해서는 수행할 초기 프로그램(부트스트랩 프로그램: bootstrap program)을 가져야한다. 이 프로그램은 펌웨어라고 알려져 있는 컴퓨터 내의 읽기 전용 메모리(ROM)나 EEPROM에 저장된다. 이것은 CPU레지스터로부터, 장치 제어기, 메모리 내용 등을 포함한 시스템을 초기화한다. 부트 프로그램은 운영체제의 커널을 찾아 메모리에 적재힌다. 커널에 적재되고 수행이 시작되면 시스템과 사용자에게 서비스를 제공할 수 있다.

처음에 전력이 들어오면 CPU가 ROM에 저장된 펌웨어인 BIOS(Basic Input/Output System)를 실행시킨다. BIOS는 POST(Power On Self Test)라는 하드웨어 체크를 한다. 그 후 부팅 매체(HDD, USB ,SSD)를 선택하고 디스크의 MBR(Master Boot Record) 영역의 부트스트랩을 실행한다. 부트스트랩 과정에 RAM에 부트로더(BootLoader)가 올라간다. 부트로더는 디스크에 있는 OS(커널) 코드를 복사해 메모리에 붙여 OS가 실행된다.

이단계가 끝나면 시스템이 부트된 상태이며 시스템은 무슨 사건(event)가 발생하기를 기다린다. event가 발생하면 하드웨어나 소프트웨어로 부터 발생한 인터럽트에 의해 신호가 보내진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있으며 소프트웨어는 시스템 호출을 실행하여 인터럽트를 발생시킨다.

- BIOS(Basic Input/Output System) : 컴퓨터 장치들과 입력과 출력을 조절하는 소프트웨어. Hardware <-> BIOS <-> 운영체제(OS) 구조.
- MBR(Master Boot Record) : 모든 기억장치는 첫 번째 섹터(512바이트)에 MBR을 갖고 있다. 파티션을 만들 때 필요한 파티션에 대한 정보 4개를 기록할 수 있는 64바이트 공간과 디스크에 있는 운영체제 코드를 복사해서 메모리에 올려주는 부트 로더가 저장되어 있다.

## 운영체제 서비스
운영체제는 프로그램 실행 환경을 제공한다. 운영체제 서비스는 프로그래머가 프로그래밍을 쉽게할 수 있는 편리함을 제공한다.

<p align="center"><img src = "https://user-images.githubusercontent.com/40592785/107342895-22092d00-6b04-11eb-91a6-a128b7a24744.jpg" width="400" height="300"></p>

#### 사용자 인터페이스
크게 두가지 CLI(Command Line Interface) GUI(Graphical User Interface)

CLI는 명령어 라인 인터페이스를 제공하거나 명령어 해석기를 제공한다. UNIX나 Linux 시스템에서는 셸(shell)이라는 해석기를 제공하며 사용자가 선택할 수 있는 여러 셸이 있다. 명령어 해석기의 중요한 기능은 사용자가 지정한 명령을 가져와서 그것을 수행하는 것이다. 이 명령어 들은 두가지 방식으로 구현되는데 한가지는 명령 해석기 자체에 명령 실행 코드를 갖고 있어서 rm file.txt 같은 명령이 들어온다고 하면은 명령해석기의 여러 부분 중 명령어 코드 부분으로 분기하여 실행하고 적절한 시스템 호출을 한다. 또 다른 UNIX에 의해 사용되는 방법은, 시스템 프로그램에 명령을 구현해 놓고 명령 해석기는 rm이 무엇인지 모르며 rm이라 불리는 파일을 찾아서 메모리에 적재하고 매개변수로 file.txt를 실행하는 형태이다.

GUI : 80년대 Apple 매킨토시에 의해 널리 사용됨 기원은 더 이전.

#### 시스템 호출(System Calls)
시스템 호출은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다. 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 간단한 프로그램을 작성한다고 가정하면 프로그램이 필요한 첫 번째 입력은 두 개의 파일(입력 파일, 출력 파일) 일것이다. CLI나 GUI가 파일의 이름을 요청하고 파일이 권한이 없어 접근 불가할 때 출력하는 콘솔 메세지 등등 모두 일련의 시스템 호출이다. 여러 개의 시스템 호출이 더 있을 테지만 생략하고 간단한 파일 복사 과정에도 많은 시스템 호출을 필요로한다.

<p align="center"><img src = "https://user-images.githubusercontent.com/40592785/107343190-73192100-6b04-11eb-8f53-59ba902808c2.jpg" width="400" height="300"></p>


대부분의 개발자들은 API에 따라 설계한다. API는 각 함수에 전달되어야할 매개변수들과 반환 값을 포함하여 사용가능한 함수의 집합을 명시한다. Windows API,POSIX 기반(UNIX,Linux 및 MAC OS X) POSIX API, Java API 시스템호출 대신 API를 이용하여 개발하는 이유는 호환성과 관련이 있다. 프로그램을 제작할 때 같은 aPI를 지원하는 어떤 시스템이건 컴파일되고 실행될 수 있기 때문이다.

###### 시스템 호출 유형
- 프로세스 제어 : end, abort, load, 수행(execute), 프로세스 생성,종료 등
- 파일 조작 : 파일 생성,삭제,열기,닫기 등
- 장치 관리 : 장치를 요구, 방출, 읽기, 쓰기, 장치의 속성 설정 등
- 정보 유지 : 시간과 날짜의 설정과 획득, 시스템 데이터 설정과 획득 등
- 통신 : 통신의 연결과 생성, 제거, 메세지의 송신, 수신


	-출처
		(운영체제,Operating System: COmcepts 9th edition, Abraham Silberschatz, Peter B. Galvin, Greg Gagne)
