03 프로세스
==

##### 프로세스 개념

프로세스는 메인 메모리에 할당되어 실행중인 상태의 프로그램을 말한다. 프로세스는 일반적으로 함수의 매개변수, 복귀 조수와 로컬 변수와 같은 임시적인 자료를 가지는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 실행 중 동적으로 할당되는 힙도 포함한다.

##### 프로세스 메모리 구조

- 스택(Stack) : 지역변수(중괄호 안에서 선언된 변수)
- 힙(Heap) : 동적할당을 위한 메모리 영역 // C: malloc & free , Java : new
- 데이터(Data) : 초기화된 전역 변수, static 변수
- 텍스트(Text) : Instruction(기계어) 프로그램을 실행시키는 실행 파일 내의 명령어들, 프로그램을 시작할 때 프로세서가 디스크에서 읽어 실행하는 컴파일한 프로그램을 저장한다. 읽기 전용이므로 이 영역을 침범해서 쓰기를 시도하면 오류가 발생해 프로그램이 종료된다.

![image](https://user-images.githubusercontent.com/40592785/107960415-f4caec00-6fe7-11eb-9437-b2f7e88da5f3.png)

프로세스 상태

프로세스는 실행되면서 그 상태가 변한다. 사용자가 프로그램을 실행하면 프로세스가 생성되고 준비 리스트에 추가된다. 프로세스는 프로세서(CPU)가 사용가능한 상태가 되면 CPU를 할당 받고(스케줄러 역할) 이를 준비상태에서 실행상태로 상태전이 된다고 한다. 이 과정을 디스패치(Dispatching)이라고 한다.

- New : 프로세스가 생성 중이다.
- Ready(준비) : 프로세스가 처리기에 할당되기를 기다린다.
- Running(실행) : 명령어들이 실행되고 있다.
- Waiting(대기) : 프로세스가 어떤 사건이 일어나기를 기다린다.
- Terminated(종료) : 프로세스의 실행이 종료되었다.

![image](https://user-images.githubusercontent.com/40592785/107949531-c2fe5900-6fd8-11eb-9e7d-c0b748173cf3.png)

##### 프로세스 제어블록

각 프로세스는 운영체제에서 프로세스 제어 블록(PCB)에 의해 표현된다.

- 프로세스 상태 : 위의 New, 준비, 실행, 대기, 종료
- 프로그램 카운터 : 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터들 : 컴퓨터 구조에 따라 다양한 타입을 가진다. 누산기(Accumlator), 인덱스 레지스터, 스택 레지스터 등의 정보는 프로그램 카운터와 함께 인터럽트 발생 시 저장되어야 한다.
- CPU - 스케줄링 정보 : 이 정보는 프로세스 우선순위와 스케줄 큐에 대한 포인터, 매개변수들을 포함한다. 
- 메모리 관리 정보 : 운영체제에 의해 사용되는 메모리 기준 레지스터와 한계 레지스터의 값, 페이지 테이블, 세그먼트 테이블을 포함한다.
- 회계 정보 : CPU 사용시간과 경과된 실시간, 시간 제한, 프로세스 번호 등을 포함한다.
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

![image](https://user-images.githubusercontent.com/40592785/107960515-188e3200-6fe8-11eb-9532-9cc7d05b46cc.png)



##### 프로세스 스케줄링

다중 프로그래밍의 목적은 CPU 이용을 최대화 하기 위하여 항상 어떤 프로세스가 실행되도록 하는 데 있다. 이 목적을 달성하기 위해 **프로세스 스케줄러**는 CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택한다. 단일 처리기 시스템에서는 실행 중인 프로세스가 한 개 이상 있을 수 없다. 나머지 프로세스는 CPU가 다시 스케줄 될 때 까지 대기해야한다. 

스케줄링 -> CPU 할당 순서 및 방법을 결정하는 일. 알고리즘에 따라 결정된다.

프로세스가 시스템에 들어오면, 이들은 잡 큐에 놓여진다. 이 큐는 시스템 안의 모든 프로세스로 구성된다. 메인 메모리에 존재하며, 준비 완료 상태에서 실행을 대기하는 프로세스들은 준비 완료 큐에 유지된다. 프로세스는 CPU를 할당받을(Dispatch) 때까지 준비 완료 큐에서 대기한다. 프로세스가 CPU에 할당되면 여러가지 사건이 발생한다.

- 프로세스가 입출력 요청을 하여 입출력 큐에 넣어짐
- 프로세스가 새로운 자식 프로세스를 생성하고 자식 프로세스의 종료를 기다림
- 프로세스가 인터럽트에 의해 CPU로부터 제거, 준비완료 큐로 들어감

프로세스는 종료될 때까지 이런 주기를 반복하며 종료되면 모든 큐에서 삭제되고 PCB와 자원을 반납한다.

인터럽트에 의해 CPU를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다. 이를 **문맥 교환(context switch)** 이라고 한다.  문맥은 프로세스의 PCB에 표현된다. 이 문맥 교환이 진행될 동안 시스템은 아무런 유용한 일을 못하기 때문에 문맥 교환 시간은 순수한 오버헤드이다. 이 작업의 양은 운영체제의 메모리 관리 기법에 따라 달라진다.

##### 프로세스간 통신

공유 메모리와 메세지 전달 두가지 모델이 있으며 대부분의 시스템들이 이 두 가지를 모두 구현한다. 공유 메모리는 협력 프로세스들에 의해 공유되는 메모리 영역이 구축되고, 메시지 전달 모델은 충돌을 회피할 필요가 없어 적은 양의 데이터를 교환하는 데 유용하다.

1) 공유메모리

서로 다른 프로세스가 특정 메모리를 공유하면 데이터를 더 빠르게 접근할 수 있기 때문에 프로그램을 더 효율적으로 만들 수 있다

2) 메시지 전달

메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 동작을 동기화할 수 있는 기법을 제공한다. 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산환경에 유용하다.


	-출처
		(운영체제,Operating System: COmcepts 9th edition, Abraham Silberschatz, Peter B. Galvin, Greg Gagne)
